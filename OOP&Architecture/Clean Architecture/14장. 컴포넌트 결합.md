# 14장 컴포넌트 결합

해당 장에서 다룰 세 가지 원칙(ADP/SDP/SAP)은 **컴포넌트 사이의 관계**를 설명한다.

<br/>

## ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

혹시 당신이 무언가를 작동하게 만든 후 퇴근했는데, 다음날 전혀 돌아가지 않는 경험이 있는가? 이는 당신이 퇴근한 사이에 누군가 당신이 의존하고 있던 무언가를 수정했기 때문이다. 이를 ‘숙취 증후군’이라고 하고, 이를 해결하기 위한 두 가지 해결책이 있다.
    
  - 주 단위 빌드
  - 의존성 비순환 원칙
  
  첫 번째 해결책인 주 단위 빌드는 쓰여져 있는 그대로 해석하면 된다. 각자 작업을 진행하고, 매주 한 번 모여 코드를 통합한 뒤 빌드하는 방법이다. 작은 규모의 프로젝트에서는 가능한 방법이지만, 규모가 커질수록 통합에 드는 시간이 늘어날 것이다. 이는 빌드 주기가 늦출것이고, 이는 프로젝트의 위험성이 커지고 통합, 테스트를 수행하기 어렵게 만든다. 
  
  이 문제의 해결책은 개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 것이다. 컴포넌트는 개별 개발자, 단일 팀이 책임질 수 있는 작업 단위가 된다. 담당자는 컴포넌트에 릴리즈 번호를 부여하고, 나머지 개발자는 사용할 릴리즈 버전을 선택하여 사용이 가능하다. 
  해당 방법이 성공적으로 동작하려면 **컴포넌트 사이의 의존성 구조를 반드시 관리**해야 한다. **의존성 구조에 순환이 있어서는 안된다.**
  
  <br/>
  
  ### 순환이 컴포넌트 의존성 그래프에 미치는 영향
  
  우측 그림과 같이 의존성 그래프에 순환이 발생했다고 가정해보자.
  
<img width="400" alt="스크린샷 2025-04-01 오전 2 44 36" src="https://github.com/user-attachments/assets/154d28d3-818d-41b6-8693-bec4f1d8209f" /> <img width="400" alt="스크린샷 2025-04-01 오전 2 44 55" src="https://github.com/user-attachments/assets/cc4285e5-a0db-4ec8-b844-de343484c660" />

  
  이로 인해 미치는 영향은 아래와 같다.
  
  - Iteractors, Entities, Authorizer는 하나의 컴포넌트가 되어 버린다. 따라서 모두 동일한 릴리스를 사용해야한다.
  - 컴포넌트 분리가 어려워진다.
  - 단위 테스트를 하고 릴리스를 하는 일도 어려워지며 에러도 쉽게 발생한다.
  - 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 힘들다

<br/>
    
  ### 순환 끊기
  
  컴포넌트 사이의 순환을 끊기 위한 두 가지 해결방법이 있다
  
  - 의존성 역전 원칙 적용
    User가 필요로 하는 메서드를 제공하는 Permissions 인터페이스를 만들어 Entities에 위치시킨다. Authorizer에서는 이 인터페이스를 상속받는다.

      <img width="462" alt="스크린샷 2025-04-01 오전 2 46 54" src="https://github.com/user-attachments/assets/9dbecbe6-5cc9-4ccd-ae8e-a174dc4f8864" />

      
  - Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트 생성
    두 컴포넌트가 모두 의존하는 클래스들을 새로운 Permissions 컴포넌트로 이동시킨다.
    
      <img width="470" alt="스크린샷 2025-04-01 오전 2 47 12" src="https://github.com/user-attachments/assets/8c4655c9-5b4d-441a-9d65-37fe14c5009c" />
 
  
  두번째 해결책과 같이 의존성 구조를 수정하는 과정에서 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수도 있다. 하지만 이는 애플리케이션이 성장하는 과정에서 당연한 결과이며, **순환이 발생하면 어떤 식으로든 끊어야 한다.**
  

<br/><br/>


## 하향식(top-down) 설계

> 컴포넌트 구조는 하향식으로 설계될 수 없다.

컴포넌트 의존성 그래프는 애플리케이션의 기능과는 거의 관련이 없다. **오히려 빌드 가능성과 유지보수성을 보여준다.** 따라서 빌드하거나 유지보수할 소프트웨어가 없는 프로젝트 초기에 컴포넌트 구조를 설계할 수 없다. 컴포넌트 의존성 구조는 시스템이 성장하고 변경될 때, 함께 관리되어야 한다.
    

<br/><br/>

## SDP: 안정된 의존성 원칙(Stable Dependencies Principle)

> 안정성의 방향으로(**더 안정된 쪽에) 의존하라**

설계는 변경된다. 따라서 우리는 변경을 생각하며 작업을 할 것이다. 공통 폐쇄 원칙을 준수하면, 변경에 영향을 받는 컴포넌트를 조정할 수 있다. 컴포넌트가 A유형의 변경에는 영향을 받지 않게하고, B유형의 변경에만 영향을 받도록 설계할 수 있다는 말이다.

<br/>

### 그러면 어떤 유형의 변경에 영향을 받지 않게하고, 어떤 유형에 영향을 받도록 해야할까?

변경이 쉽지 않은 컴포넌트가 변경이 예상되는 컴포넌트에 의존하게 만들면 안된다. 만약, 의존하게 된다면 변동성이 큰 컴포넌트도 결국 변경이 어려워지게 될 것이다.
예를 들어, 당신이 변경하기 쉽도록 A모듈을 만들었다고 해보자. 그런데 동료가 자신이 만든 B모듈을 A모듈에 의존성을 달았다. 그러면 당신이 만든 A모듈을 쉽게 변경할 수 있을까? 아닐 것이다.


`👉 안정된 의존성 원칙: (변경하기 어려운 모듈이 → 변경하기 쉽게 만들어진 모듈)에 의존하지 않도록 설계
`

<br/>

### 안정성

SDP는 더 안정된 쪽에 의존하는 원칙이다. 그렇다면 안정성을 어떻게 정의할 수 있을까? 변경하기 어려울수록 안정성이 높다. 
> 안정성은 **변경을 만들기 위해 필요한 작업량**과 관련된다.

X 컴포넌트는 안정적일까?

<img width="493" alt="스크린샷 2025-04-01 오전 2 54 27" src="https://github.com/user-attachments/assets/e6e037c8-b674-4286-b0cb-9db0ec9d3d18" />

그렇다
- 세 컴포넌트가 X에 의존하고 있기 때문에, 의존하는 모든 컴포넌트를 만족시키며 변경하려면 상당한 노력이 든다.
    - X는 세 컴포넌트를 책임진다
- X는 어디에도 의존하고 있지 않기때문에, X가 변경되도록 만들 수 있는 외적인 영향은 없다.
    - X는 독립적이다

<br/>

Y 컴포넌트는 안정적일까?

<img width="495" alt="스크린샷 2025-04-01 오전 2 54 59" src="https://github.com/user-attachments/assets/58ec67bb-a482-4917-bf51-4ffaca018548" />

그렇지 않다

- 어떤 컴포넌트도 Y에 의존하고 있지 않기 때문에, Y의 변경은 쉽다.
    - Y는 책임성이 없다
- Y는 세 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지다.
    - Y는 의존적이다

<br/>

### 안정성 지표

정리해보면, 

- 안으로 들어오는 Fan-in 의존성이 많을수록(=나에게 많이 의존할수록) 안정적이고,
- 밖으로 나가는 Fan-out 의존성이 적을수록 (=외부에 적게 의존할수록) 안정적이다.
- I(불안정성): I=Fan-out / (Fan-in + Fan-out) (I=0:최고 안정 / I=1: 최고 불안정)

<br/>

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

위의 내용까지 읽고 모든 컴포넌트가 안정적이어야 좋다고 생각했다. 하지만 모든 컴포넌트가 안정적이면 어떻게 될까? 변경이 불가능하다. 이는 바람직하지 않다. 불안정한 컴포넌트와 안정된 컴포넌트가 존재하는 상태여야한다.

아래 그림은 세 컴포넌트로 구성된 시스템의 이상적인 구성이다. 위쪽에 변경가능한 컴포넌트(instable)가 있고, 아래 안정된 컴포넌트(stable)에 의존한다. 이렇게 불안정한 컴포넌트를 위쪽에 두고 의존성 그래프를 그리면 좋다. 만약 위로 향하는 화살표가 있으면 SDP를 위배한 것이다.

<img width="486" alt="스크린샷 2025-04-01 오전 2 55 31" src="https://github.com/user-attachments/assets/26435b65-6ea4-408a-b8c1-b6b79ffa4213" />

<br/>

아래 그림은 Stable 컴포넌트가 Flexible 컴포넌트에 의존하고있어 SDP를 위반하였다. Flexible 컴포넌트는 변경하기 어렵게 되었다.

<img width="497" alt="스크린샷 2025-04-01 오전 2 55 46" src="https://github.com/user-attachments/assets/640d735f-c167-478a-96a0-115a98e736e0" />

<br/>

이를 DIP를 통해 해결할 수 있다. 추상 컴포넌트(UServer)는 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 대상이다.

<img width="493" alt="스크린샷 2025-04-01 오전 2 56 00" src="https://github.com/user-attachments/assets/8bd29af0-d8ee-476e-9cb6-d60cbf05f9ff" />



<br/><br/>


## SAP: 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
    
### 고수준 정책을 어디에 위치시켜야 하는가?

고수준 정책(모듈)은 주요로직,정책 포함하는 한마디로 큰 그림을 말한다. 저수준 정책(모듈)은 세부사항을 구현한다. 따라서 고수준 정책을 포함한다면 안정된 컴포넌트(I=0)에 포함되어야한다. 하지만 고수준 정책을 안정된 컴포넌트에 위치시킨다면, 해당 컴포넌트는 변경하기 어려워진다.

<br/>

### 컴포넌트가 안정적이면서(I=0) 변경에 충분히 대응하도록 유연할 수는 없을까?

가능하다. **OCP**에서 우리는 **추상 클래스**를 만듦으로써 기존 클래스를 수정하지 않고도 확장할 수 있도록 하였다.

<br/>

### 안정된 추상화 원칙

> 안정성과 추상화 정도 사이의 관계를 정의한다.

- 안정적인 컴포넌트는 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다. 안정된 컴포넌트가 확장 가능해지면 유연성을 얻을 수 있다.
- 불안정한 컴포넌트는 구체 컴포넌트여야 한다. 컴포넌트가 불안정하므로 내부의 구체적인 코드를 쉽게 변경할 수 있다.

`👉 안정된 추상화 원칙: 많이 안정되어 있을수록, 추상화의 수준이 높아야 변경이 가능해진다.`

- `DIP = SDP + SAP`
    - 의존성은 안정된 방향으로(:SDP)
    - 안정성은 추상화의 정도 의미(:SAP)
    - 따라서, 의존성은 추상화 방향으로 향함(:DIP)
        - 하지만 DIP는 클래스에 대한 원칙(추상적 or 추상적이지 않음)
        - SDP와 SAP는 컴포넌트에 대한 원칙(어떤 부분은 추상적이고, 다른 부분은 그렇지 않음)
  
<br/><br/>

## 결론

지표는 임의로 결정된 표준을 기초로 한 측정값에 불과하다. 지표로부터 유용한 것을 찾고, 적절하게 사용하자.
